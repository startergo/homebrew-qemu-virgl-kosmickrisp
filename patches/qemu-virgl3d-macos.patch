diff -uar qemu-clean/include/ui/console.h qemu-fixed/include/ui/console.h
--- qemu-clean/include/ui/console.h	2026-01-12 19:51:18
+++ qemu-fixed/include/ui/console.h	2026-01-13 15:07:40
@@ -420,18 +420,15 @@
 #ifdef CONFIG_OPENGL
 bool console_gl_check_format(DisplayChangeListener *dcl,
                              pixman_format_code_t format);
-void surface_gl_create_texture(QemuGLShader *gls,
-                               DisplaySurface *surface);
+void surface_gl_create_texture(DisplaySurface *surface);
 bool surface_gl_create_texture_from_fd(DisplaySurface *surface,
                                        int fd, GLuint *texture,
                                        GLuint *mem_obj);
-void surface_gl_update_texture(QemuGLShader *gls,
-                               DisplaySurface *surface,
+void surface_gl_update_texture(DisplaySurface *surface,
                                int x, int y, int w, int h);
 void surface_gl_render_texture(QemuGLShader *gls,
                                DisplaySurface *surface);
-void surface_gl_destroy_texture(QemuGLShader *gls,
-                               DisplaySurface *surface);
+void surface_gl_destroy_texture(DisplaySurface *surface);
 void surface_gl_setup_viewport(QemuGLShader *gls,
                                DisplaySurface *surface,
                                int ww, int wh);
diff -uar qemu-clean/include/ui/egl-helpers.h qemu-fixed/include/ui/egl-helpers.h
--- qemu-clean/include/ui/egl-helpers.h	2026-01-12 19:51:18
+++ qemu-fixed/include/ui/egl-helpers.h	2026-01-13 15:07:40
@@ -59,7 +59,9 @@
 
 #endif
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
+
+int qemu_egl_init_dpy_metal(DisplayGLMode mode, uint64_t id);
 
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
diff -uar qemu-clean/include/ui/gtk.h qemu-fixed/include/ui/gtk.h
--- qemu-clean/include/ui/gtk.h	2026-01-12 19:51:18
+++ qemu-fixed/include/ui/gtk.h	2026-01-13 15:07:40
@@ -21,7 +21,7 @@
 #include "ui/clipboard.h"
 #include "ui/console.h"
 #include "ui/kbd-state.h"
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #include "ui/egl-helpers.h"
 #include "ui/egl-context.h"
 #endif
@@ -44,7 +44,7 @@
     double preferred_scale;
     double scale_x;
     double scale_y;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     EGLContext ectx;
     EGLSurface esurface;
diff -uar qemu-clean/include/ui/sdl2.h qemu-fixed/include/ui/sdl2.h
--- qemu-clean/include/ui/sdl2.h	2026-01-12 19:51:18
+++ qemu-fixed/include/ui/sdl2.h	2026-01-13 15:07:40
@@ -22,7 +22,7 @@
 #endif
 
 #include "ui/kbd-state.h"
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 # include "ui/egl-helpers.h"
 #endif
 
@@ -45,7 +45,7 @@
     bool gui_keysym;
     SDL_GLContext winctx;
     QKbdState *kbd;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     egl_fb guest_fb;
     egl_fb win_fb;
diff -uar qemu-clean/include/ui/spice-display.h qemu-fixed/include/ui/spice-display.h
--- qemu-clean/include/ui/spice-display.h	2026-01-12 19:51:18
+++ qemu-fixed/include/ui/spice-display.h	2026-01-13 15:07:40
@@ -27,7 +27,7 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
-#if defined(CONFIG_OPENGL) && defined(CONFIG_GBM)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL) && defined(CONFIG_GBM)
 #  define HAVE_SPICE_GL 1
 #  include "ui/egl-helpers.h"
 #  include "ui/egl-context.h"
diff -uar qemu-clean/meson.build qemu-fixed/meson.build
--- qemu-clean/meson.build	2026-01-12 19:51:18
+++ qemu-fixed/meson.build	2026-01-13 15:07:41
@@ -1217,7 +1217,7 @@
 endif
 
 cocoa = dependency('appleframeworks',
-                   modules: ['Cocoa', 'CoreVideo', 'QuartzCore'],
+                   modules: ['Cocoa', 'CoreVideo', 'Metal', 'OpenGL', 'QuartzCore'],
                    required: get_option('cocoa'))
 
 vmnet = dependency('appleframeworks', modules: 'vmnet', required: get_option('vmnet'))
@@ -1801,14 +1801,13 @@
                          required: get_option('coreaudio'))
 endif
 
+egl = not_found
 opengl = not_found
 if not get_option('opengl').auto() or have_system or have_vhost_user_gpu
-  epoxy = dependency('epoxy', method: 'pkg-config',
+  opengl = dependency('epoxy', method: 'pkg-config',
                       required: get_option('opengl'))
-  if cc.has_header('epoxy/egl.h', dependencies: epoxy)
-    opengl = epoxy
-  elif get_option('opengl').enabled()
-    error('epoxy/egl.h not found')
+  if cc.has_header('epoxy/egl.h', dependencies: opengl)
+    egl = opengl
   endif
 endif
 gbm = not_found
@@ -2507,6 +2506,7 @@
                        cc.has_function('numa_has_preferred_many',
                                        dependencies: numa))
 endif
+config_host_data.set('CONFIG_EGL', egl.found())
 config_host_data.set('CONFIG_OPENGL', opengl.found())
 config_host_data.set('CONFIG_PLUGIN', get_option('plugins'))
 config_host_data.set('CONFIG_RBD', rbd.found())
diff -uar qemu-clean/qapi/ui.json qemu-fixed/qapi/ui.json
--- qemu-clean/qapi/ui.json	2026-01-12 19:51:18
+++ qemu-fixed/qapi/ui.json	2026-01-13 15:07:39
@@ -1521,7 +1521,8 @@
     { 'name': 'none' },
     { 'name': 'gtk', 'if': 'CONFIG_GTK' },
     { 'name': 'sdl', 'if': 'CONFIG_SDL' },
-    { 'name': 'egl-headless', 'if': 'CONFIG_OPENGL' },
+    { 'name': 'egl-headless',
+              'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_EGL'] } },
     { 'name': 'curses', 'if': 'CONFIG_CURSES' },
     { 'name': 'cocoa', 'if': 'CONFIG_COCOA' },
     { 'name': 'spice-app', 'if': 'CONFIG_SPICE' },
@@ -1561,7 +1562,7 @@
       'cocoa': { 'type': 'DisplayCocoa', 'if': 'CONFIG_COCOA' },
       'curses': { 'type': 'DisplayCurses', 'if': 'CONFIG_CURSES' },
       'egl-headless': { 'type': 'DisplayEGLHeadless',
-                        'if': 'CONFIG_OPENGL' },
+                        'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_EGL'] } },
       'dbus': { 'type': 'DisplayDBus', 'if': 'CONFIG_DBUS_DISPLAY' },
       'sdl': { 'type': 'DisplaySDL', 'if': 'CONFIG_SDL' }
   }
diff -uar qemu-clean/qemu-options.hx qemu-fixed/qemu-options.hx
--- qemu-clean/qemu-options.hx	2026-01-12 19:51:18
+++ qemu-fixed/qemu-options.hx	2026-01-13 15:07:42
@@ -2148,7 +2148,7 @@
     "              [,show-cursor=on|off][,left-command-key=on|off]\n"
     "              [,full-screen=on|off][,zoom-to-fit=on|off]\n"
 #endif
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     "-display egl-headless[,rendernode=<file>]\n"
 #endif
 #if defined(CONFIG_DBUS_DISPLAY)
Only in qemu-fixed: qemu.tar.gz
diff -uar qemu-clean/ui/cocoa.m qemu-fixed/ui/cocoa.m
--- qemu-clean/ui/cocoa.m	2026-01-12 19:51:18
+++ qemu-fixed/ui/cocoa.m	2026-01-13 15:07:39
@@ -22,9 +22,12 @@
  * THE SOFTWARE.
  */
 
+#define GL_SILENCE_DEPRECATION
+
 #include "qemu/osdep.h"
 
 #import <Cocoa/Cocoa.h>
+#import <Metal/Metal.h>
 #import <QuartzCore/QuartzCore.h>
 #include <crt_externs.h>
 
@@ -51,6 +54,10 @@
 #include <Carbon/Carbon.h>
 #include "hw/core/cpu.h"
 
+#ifdef CONFIG_EGL
+#include "ui/egl-context.h"
+#endif
+
 #ifndef MAC_OS_VERSION_14_0
 #define MAC_OS_VERSION_14_0 140000
 #endif
@@ -68,6 +75,8 @@
 #define UC_CTRL_KEY "\xe2\x8c\x83"
 #define UC_ALT_KEY "\xe2\x8c\xa5"
 
+#define EGL_METAL_TEXTURE_ANGLE 0x34A7
+
 typedef struct {
     int width;
     int height;
@@ -75,33 +84,14 @@
 
 @class QemuCocoaPasteboardTypeOwner;
 
-static void cocoa_update(DisplayChangeListener *dcl,
-                         int x, int y, int w, int h);
-
-static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface);
-
-static void cocoa_refresh(DisplayChangeListener *dcl);
-static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, bool on);
-static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor);
-
-static const DisplayChangeListenerOps dcl_ops = {
-    .dpy_name          = "cocoa",
-    .dpy_gfx_update = cocoa_update,
-    .dpy_gfx_switch = cocoa_switch,
-    .dpy_refresh = cocoa_refresh,
-    .dpy_mouse_set = cocoa_mouse_set,
-    .dpy_cursor_define = cocoa_cursor_define,
-};
-static DisplayChangeListener dcl = {
-    .ops = &dcl_ops,
-};
+static DisplayChangeListener dcl;
+static DisplaySurface *surface;
 static QKbdState *kbd;
 static int cursor_hide = 1;
 static int left_command_key_enabled = 1;
 static bool swap_opt_cmd;
 
-static CGInterpolationQuality zoom_interpolation = kCGInterpolationNone;
+static bool zoom_interpolation;
 static NSTextField *pauseLabel;
 
 static bool allow_events;
@@ -111,6 +101,59 @@
 static QemuEvent cbevent;
 static QemuCocoaPasteboardTypeOwner *cbowner;
 
+#ifdef CONFIG_OPENGL
+
+@interface QemuCGLLayer : CAOpenGLLayer
+@end
+
+static GLint gl_scanout_x;
+static GLint gl_scanout_y;
+static GLsync gl_scanout_sync;
+static GLuint gl_scanout_id;
+static QEMUGLContext gl_ctx;
+static bool gl_needs_display;
+static bool gl_scanout_y_flip;
+static bool gl_scanout_flushed;
+
+#ifdef CONFIG_EGL
+static QEMUGLContext gl_view_ctx;
+#endif
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl);
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params);
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static const DisplayGLCtxOps dgc_ops = {
+    .dpy_gl_ctx_is_compatible_dcl = cocoa_gl_is_compatible_dcl,
+    .dpy_gl_ctx_create            = cocoa_gl_create_context,
+    .dpy_gl_ctx_destroy           = cocoa_gl_destroy_context,
+    .dpy_gl_ctx_make_current      = cocoa_gl_make_context_current,
+};
+
+static DisplayGLCtx dgc = {
+    .ops = &dgc_ops,
+};
+
+static void cocoa_gl_scanout_acquire(void)
+{
+    glWaitSync(gl_scanout_sync, 0, GL_TIMEOUT_IGNORED);
+    glDeleteSync(gl_scanout_sync);
+}
+
+static void cocoa_gl_scanout_release(void)
+{
+    gl_scanout_sync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+    glFlush();
+}
+
+#endif
+
 // Utility functions to run specified code block with the BQL held
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
@@ -303,7 +346,6 @@
 @interface QemuCocoaView : NSView
 {
     QEMUScreen screen;
-    pixman_image_t *pixman_image;
     /* The state surrounding mouse grabbing is potentially confusing.
      * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
      *   pointing device an absolute-position one?"], but is only updated on
@@ -322,7 +364,6 @@
     int mouseY;
     bool mouseOn;
 }
-- (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) setFullGrab:(id)sender;
@@ -331,7 +372,6 @@
 - (bool) handleEventLocked:(NSEvent *)event;
 - (void) notifyMouseModeChange;
 - (BOOL) isMouseGrabbed;
-- (QEMUScreen) gscreen;
 - (void) raiseAllKeys;
 @end
 
@@ -352,6 +392,9 @@
 
 @implementation QemuCocoaView
 - (id)initWithFrame:(NSRect)frameRect
+#ifdef CONFIG_OPENGL
+                gl:(DisplayGLMode)gl
+#endif
 {
     COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
 
@@ -378,10 +421,28 @@
         [self setClipsToBounds:YES];
 #endif
         [self setWantsLayer:YES];
+
+#ifdef CONFIG_OPENGL
+        if (gl) {
+            CALayer *layer;
+
+            if (gl == DISPLAY_GL_MODE_ES) {
+                CAMetalLayer *metalLayer = [CAMetalLayer new];
+                [metalLayer setDrawableSize:frameRect.size];
+                metalLayer.autoresizingMask = kCALayerNotSizable;
+                layer = metalLayer;
+            } else {
+                layer = [QemuCGLLayer new];
+            }
+
+            [self setLayer:layer];
+            [layer release];
+        }
+#endif
+
         cursorLayer = [[CALayer alloc] init];
         [cursorLayer setAnchorPoint:CGPointMake(0, 1)];
-        [cursorLayer setAutoresizingMask:kCALayerMaxXMargin |
-                                         kCALayerMinYMargin];
+        [cursorLayer setZPosition:1];
         [[self layer] addSublayer:cursorLayer];
 
     }
@@ -392,10 +453,6 @@
 {
     COCOA_DEBUG("QemuCocoaView: dealloc\n");
 
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
     if (eventsTap) {
         CFRelease(eventsTap);
     }
@@ -411,6 +468,53 @@
     return YES;
 }
 
+#ifdef CONFIG_OPENGL
+- (BOOL)wantsUpdateLayer
+{
+    return display_opengl;
+}
+
+- (void)glDraw
+{
+    BQL_LOCK_GUARD();
+
+    /* Skip rendering if no scanout texture is bound yet, or the surface
+     * is not ready. The white screen fix for unflushed texture is handled
+     * in drawInCGLContext: for Core mode. */
+    if (!surface || gl_scanout_id == 0 ||
+        surface_width(surface) == 0 || surface_height(surface) == 0) {
+        return;
+    }
+
+    GLint filter = zoom_interpolation ? GL_LINEAR : GL_NEAREST;
+    NSSize frame = [self convertSizeToBacking:[self frame].size];
+    GLuint fb;
+    GLuint x1 = gl_scanout_x;
+    GLuint y1;
+    GLuint x2 = gl_scanout_x + surface_width(surface);
+    GLuint y2;
+
+    if (gl_scanout_y_flip) {
+        y1 = gl_scanout_y + surface_height(surface);
+        y2 = gl_scanout_y;
+    } else {
+        y1 = gl_scanout_y;
+        y2 = gl_scanout_y + surface_height(surface);
+    }
+
+    cocoa_gl_scanout_acquire();
+    glGenFramebuffers(1, &fb);
+    glBindFramebuffer(GL_READ_FRAMEBUFFER, fb);
+    glFramebufferTexture2D(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                           GL_TEXTURE_2D, gl_scanout_id, 0);
+    glBlitFramebuffer(x1, y1, x2, y2, 0, 0, frame.width, frame.height,
+                      GL_COLOR_BUFFER_BIT, filter);
+    glDeleteFramebuffers(1, &fb);
+    cocoa_gl_scanout_release();
+    gl_needs_display = false;
+}
+#endif
+
 - (void) viewDidMoveToWindow
 {
     [self resizeWindow];
@@ -447,29 +551,43 @@
     [NSCursor unhide];
 }
 
-- (void)setMouseX:(int)x y:(int)y on:(bool)on
+- (void)updateCursorLayout
 {
-    CGPoint position;
+    [CATransaction begin];
+    [CATransaction setDisableActions:YES];
 
-    mouseX = x;
-    mouseY = y;
-    mouseOn = on;
+    if (cursor) {
+        CGFloat scale = [self bounds].size.width / screen.width;
+        CGPoint position;
+        CGRect bounds = CGRectZero;
 
-    position.x = mouseX;
-    position.y = screen.height - mouseY;
+        position.x = mouseX * scale;
+        position.y = (screen.height - mouseY) * scale;
 
-    [CATransaction begin];
-    [CATransaction setDisableActions:YES];
-    [cursorLayer setPosition:position];
+        bounds.size.width = cursor->width * scale;
+        bounds.size.height = cursor->height * scale;
+
+        [cursorLayer setBounds:bounds];
+        [cursorLayer setContentsScale:scale];
+        [cursorLayer setPosition:position];
+    }
+
     [cursorLayer setHidden:!mouseOn];
     [CATransaction commit];
 }
 
+- (void)setMouseX:(int)x y:(int)y on:(bool)on
+{
+    mouseX = x;
+    mouseY = y;
+    mouseOn = on;
+    [self updateCursorLayout];
+}
+
 - (void)setCursor:(QEMUCursor *)given_cursor
 {
     CGDataProviderRef provider;
     CGImageRef image;
-    CGRect bounds = CGRectZero;
 
     cursor_unref(cursor);
     cursor = given_cursor;
@@ -480,9 +598,6 @@
 
     cursor_ref(cursor);
 
-    bounds.size.width = cursor->width;
-    bounds.size.height = cursor->height;
-
     provider = CGDataProviderCreateWithData(
         NULL,
         cursor->data,
@@ -507,8 +622,8 @@
     CGDataProviderRelease(provider);
     [CATransaction begin];
     [CATransaction setDisableActions:YES];
-    [cursorLayer setBounds:bounds];
     [cursorLayer setContents:(id)image];
+    [self updateCursorLayout];
     [CATransaction commit];
     CGImageRelease(image);
 }
@@ -519,61 +634,58 @@
 
     // get CoreGraphic context
     CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
+    BQL_LOCK_GUARD();
 
-    CGContextSetInterpolationQuality (viewContextRef, zoom_interpolation);
+    CGContextSetInterpolationQuality(viewContextRef,
+                                     zoom_interpolation ? kCGInterpolationLow :
+                                                          kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
     // draw screen bitmap directly to Core Graphics context
-    if (!pixman_image) {
-        // Draw request before any guest device has set up a framebuffer:
-        // just draw an opaque black rectangle
-        CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
-        CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
-    } else {
-        int w = pixman_image_get_width(pixman_image);
-        int h = pixman_image_get_height(pixman_image);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(pixman_image_get_format(pixman_image));
-        int stride = pixman_image_get_stride(pixman_image);
-        CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
-            NULL,
-            pixman_image_get_data(pixman_image),
-            stride * h,
-            NULL
-        );
-        CGImageRef imageRef = CGImageCreate(
-            w, //width
-            h, //height
-            DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
-            bitsPerPixel, //bitsPerPixel
-            stride, //bytesPerRow
-            colorspace, //colorspace
-            kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
-            dataProviderRef, //provider
-            NULL, //decode
-            0, //interpolate
-            kCGRenderingIntentDefault //intent
-        );
-        // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
-        const NSRect *rectList;
-        NSInteger rectCount;
-        int i;
-        CGImageRef clipImageRef;
-        CGRect clipRect;
+    int w = surface_width(surface);
+    int h = surface_height(surface);
+    int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(surface));
+    int stride = surface_stride(surface);
 
-        [self getRectsBeingDrawn:&rectList count:&rectCount];
-        for (i = 0; i < rectCount; i++) {
-            clipRect = rectList[i];
-            clipRect.origin.y = (float)h - (clipRect.origin.y + clipRect.size.height);
-            clipImageRef = CGImageCreateWithImageInRect(
-                                                        imageRef,
-                                                        clipRect
-                                                        );
-            CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
-            CGImageRelease (clipImageRef);
-        }
-        CGImageRelease (imageRef);
-        CGDataProviderRelease(dataProviderRef);
+    CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
+        NULL,
+        surface_data(surface),
+        stride * h,
+        NULL
+    );
+    CGImageRef imageRef = CGImageCreate(
+        w, //width
+        h, //height
+        DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
+        bitsPerPixel, //bitsPerPixel
+        stride, //bytesPerRow
+        colorspace, //colorspace
+        kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
+        dataProviderRef, //provider
+        NULL, //decode
+        0, //interpolate
+        kCGRenderingIntentDefault //intent
+    );
+    // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
+    const NSRect *rectList;
+    NSInteger rectCount;
+    int i;
+    CGImageRef clipImageRef;
+    CGRect clipRect;
+
+    [self getRectsBeingDrawn:&rectList count:&rectCount];
+    for (i = 0; i < rectCount; i++) {
+        clipRect = rectList[i];
+        clipRect.origin.y = (float)h - (clipRect.origin.y + clipRect.size.height);
+        clipImageRef = CGImageCreateWithImageInRect(
+                                                    imageRef,
+                                                    clipRect
+                                                    );
+        CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
+        CGImageRelease (clipImageRef);
     }
+    CGImageRelease (imageRef);
+    CGDataProviderRelease(dataProviderRef);
 }
 
 - (NSSize)fixAspectRatio:(NSSize)max
@@ -637,9 +749,15 @@
     }
 }
 
-- (void) updateBounds
+- (void) updateScale
 {
-    [self setBoundsSize:NSMakeSize(screen.width, screen.height)];
+    if (display_opengl) {
+        [[self layer] setContentsScale:[[self window] backingScaleFactor]];
+    } else {
+        [self setBoundsSize:NSMakeSize(screen.width, screen.height)];
+    }
+
+    [self updateCursorLayout];
 }
 
 #pragma clang diagnostic push
@@ -712,28 +830,17 @@
     });
 }
 
-- (void) switchSurface:(pixman_image_t *)image
+- (void) updateScreenWidth:(int)w height:(int)h
 {
-    COCOA_DEBUG("QemuCocoaView: switchSurface\n");
+    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
 
-    int w = pixman_image_get_width(image);
-    int h = pixman_image_get_height(image);
-
     if (w != screen.width || h != screen.height) {
-        // Resize before we trigger the redraw, or we'll redraw at the wrong size
-        COCOA_DEBUG("switchSurface: new size %d x %d\n", w, h);
+        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
         screen.width = w;
         screen.height = h;
         [self resizeWindow];
-        [self updateBounds];
+        [self updateScale];
     }
-
-    // update screenBuffer
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
-    pixman_image = image;
 }
 
 - (void) setFullGrab:(id)sender
@@ -1224,7 +1331,6 @@
     }
 }
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
-- (QEMUScreen) gscreen {return screen;}
 
 /*
  * Makes the target think all down keys are being released.
@@ -1278,7 +1384,11 @@
 @end
 
 @implementation QemuCocoaAppController
+#ifdef CONFIG_OPENGL
+- (id) initWithGL:(DisplayGLMode)gl
+#else
 - (id) init
+#endif
 {
     NSWindow *window;
 
@@ -1286,16 +1396,21 @@
 
     self = [super init];
     if (self) {
+        NSRect frame = NSMakeRect(0.0, 0.0, 640.0, 480.0);
 
         // create a view and add it to the window
-        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)];
+#ifdef CONFIG_OPENGL
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:frame gl:gl];
+#else
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:frame];
+#endif
         if(!cocoaView) {
             error_report("(cocoa) can't create a view");
             exit(1);
         }
 
         // create a window
-        window = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
+        window = [[NSWindow alloc] initWithContentRect:frame
             styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
             backing:NSBackingStoreBuffered defer:NO];
         if(!window) {
@@ -1389,7 +1504,7 @@
 
 - (void)windowDidResize:(NSNotification *)notification
 {
-    [cocoaView updateBounds];
+    [cocoaView updateScale];
     [cocoaView updateUIInfo];
 }
 
@@ -1489,13 +1604,9 @@
 
 - (void)toggleZoomInterpolation:(id) sender
 {
-    if (zoom_interpolation == kCGInterpolationNone) {
-        zoom_interpolation = kCGInterpolationLow;
-        [sender setState: NSControlStateValueOn];
-    } else {
-        zoom_interpolation = kCGInterpolationNone;
-        [sender setState: NSControlStateValueOff];
-    }
+    zoom_interpolation = !zoom_interpolation;
+    [sender setState:zoom_interpolation ? NSControlStateValueOn :
+                                          NSControlStateValueOff];
 }
 
 /* Displays the console on the screen */
@@ -1763,7 +1874,7 @@
     [menuItem setState: [[cocoaView window] styleMask] & NSWindowStyleMaskResizable ? NSControlStateValueOn : NSControlStateValueOff];
     [menu addItem: menuItem];
     menuItem = [[[NSMenuItem alloc] initWithTitle:@"Zoom Interpolation" action:@selector(toggleZoomInterpolation:) keyEquivalent:@""] autorelease];
-    [menuItem setState: zoom_interpolation == kCGInterpolationLow ? NSControlStateValueOn : NSControlStateValueOff];
+    [menuItem setState: zoom_interpolation ? NSControlStateValueOn : NSControlStateValueOff];
     [menu addItem: menuItem];
     menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
     [menuItem setSubmenu:menu];
@@ -2025,29 +2136,28 @@
 static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h)
 {
+    NSRect rect = NSMakeRect(x, surface_height(surface) - y - h, w, h);
+
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        NSRect rect = NSMakeRect(x, [cocoaView gscreen].height - y - h, w, h);
         [cocoaView setNeedsDisplayInRect:rect];
     });
 }
 
 static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface)
+                         DisplaySurface *new_surface)
 {
-    pixman_image_t *image = surface->image;
-
     COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
 
-    // The DisplaySurface will be freed as soon as this callback returns.
-    // We take a reference to the underlying pixman image here so it does
-    // not disappear from under our feet; the switchSurface method will
-    // deref the old image when it is done with it.
-    pixman_image_ref(image);
+    surface = new_surface;
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        [cocoaView switchSurface:image];
+        BQL_LOCK_GUARD();
+        int w = surface_width(surface);
+        int h = surface_height(surface);
+
+        [cocoaView updateScreenWidth:w height:h];
     });
 }
 
@@ -2087,9 +2197,312 @@
     });
 }
 
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name          = "cocoa",
+    .dpy_gfx_update = cocoa_update,
+    .dpy_gfx_switch = cocoa_switch,
+    .dpy_refresh = cocoa_refresh,
+    .dpy_mouse_set = cocoa_mouse_set,
+    .dpy_cursor_define = cocoa_cursor_define,
+};
+
+#ifdef CONFIG_OPENGL
+
+@implementation QemuCGLLayer
+- (id)init
+{
+    self = [super init];
+    if (self) {
+        [self setAsynchronous:NO];
+    }
+    return self;
+}
+
+- (CGLContextObj)copyCGLContextForPixelFormat:(CGLPixelFormatObj)pf
+{
+    CGLContextObj ctx;
+    CGLCreateContext(pf, gl_ctx, &ctx);
+    return ctx;
+}
+
+- (CGLPixelFormatObj)copyCGLPixelFormatForDisplayMask:(uint32_t)mask
+{
+    CGLPixelFormatObj pix;
+    GLint npix;
+    CGLPixelFormatAttribute attribs[] = {
+        kCGLPFADisplayMask,
+        mask,
+        kCGLPFAOpenGLProfile,
+        (CGLPixelFormatAttribute)kCGLOGLPVersion_GL4_Core,
+        0
+    };
+
+    CGLChoosePixelFormat(attribs, &pix, &npix);
+
+    return pix;
+}
+
+- (void)drawInCGLContext:(CGLContextObj)ctx
+             pixelFormat:(CGLPixelFormatObj)pf
+            forLayerTime:(CFTimeInterval)t
+             displayTime:(const CVTimeStamp *)ts
+{
+    /* Before texture is flushed, draw black quad to avoid white screen */
+    if (!gl_scanout_flushed) {
+        GLfloat vertices[] = {
+            -1.0f, -1.0f,
+             1.0f, -1.0f,
+            -1.0f,  1.0f,
+             1.0f,  1.0f,
+        };
+        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, vertices);
+        glEnableVertexAttribArray(0);
+        glUseProgram(0);
+        glColor4f(0.0f, 0.0f, 0.0f, 1.0f);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        glDisableVertexAttribArray(0);
+        return;
+    }
+    [cocoaView glDraw];
+    [super drawInCGLContext:ctx
+                pixelFormat:pf
+               forLayerTime:t
+                displayTime:ts];
+}
+@end
+
+static void with_gl_ctx(CodeBlock block)
+{
+#ifdef CONFIG_EGL
+    if (gl_view_ctx) {
+        eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE,
+                       EGL_NO_SURFACE, gl_ctx);
+        block();
+        eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE,
+                       EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        return;
+    }
+#endif
+
+    CGLSetCurrentContext((CGLContextObj)gl_ctx);
+    block();
+    CGLSetCurrentContext(NULL);
+}
+
+static CGLPixelFormatObj cocoa_gl_create_cgl_pixel_format(int bpp)
+{
+    CGLPixelFormatObj pix;
+    GLint npix;
+    CGLPixelFormatAttribute attribs[] = {
+        kCGLPFAOpenGLProfile,
+        (CGLPixelFormatAttribute)kCGLOGLPVersion_GL4_Core,
+        kCGLPFAColorSize,
+        bpp,
+        kCGLPFADoubleBuffer,
+        0,
+    };
+
+    CGLChoosePixelFormat(attribs, &pix, &npix);
+
+    return pix;
+}
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (gl_view_ctx) {
+        return !eglMakeCurrent(qemu_egl_display,
+                               EGL_NO_SURFACE, EGL_NO_SURFACE, ctx);
+    }
+#endif
+
+    return CGLSetCurrentContext((CGLContextObj)ctx);
+}
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params)
+{
+    CGLPixelFormatObj format;
+    CGLContextObj ctx;
+    int bpp;
+
+#ifdef CONFIG_EGL
+    if (gl_view_ctx) {
+        QEMUGLContext egl;
+
+        eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE,
+                       EGL_NO_SURFACE, gl_ctx);
+        egl = qemu_egl_create_context(dgc, params);
+        eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE,
+                       EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+        return egl;
+    }
+#endif
+
+    bpp = PIXMAN_FORMAT_BPP(surface_format(surface));
+    format = cocoa_gl_create_cgl_pixel_format(bpp);
+    CGLCreateContext(format, gl_ctx, &ctx);
+    CGLDestroyPixelFormat(format);
+
+    return (QEMUGLContext)ctx;
+}
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (gl_view_ctx) {
+        eglDestroyContext(qemu_egl_display, ctx);
+        return;
+    }
+#endif
+
+    CGLDestroyContext(ctx);
+}
+
+static void cocoa_gl_dispatch_display(void)
+{
+#ifdef CONFIG_EGL
+    if (gl_view_ctx && gl_needs_display) {
+        return;
+    }
+#endif
+
+    gl_needs_display = true;
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+#ifdef CONFIG_EGL
+        if (gl_view_ctx) {
+            CAMetalLayer *layer = (CAMetalLayer *)[cocoaView layer];
+            id<CAMetalDrawable> drawable;
+            EGLImage image;
+
+            [layer setDrawableSize:[cocoaView convertSizeToBacking:[cocoaView frame].size]];
+
+            drawable = [layer nextDrawable];
+            if (!drawable) {
+                gl_needs_display = false;
+                return;
+            }
+
+            eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+                           gl_view_ctx);
+            image = eglCreateImage(qemu_egl_display, EGL_NO_CONTEXT,
+                                   EGL_METAL_TEXTURE_ANGLE, [drawable texture],
+                                   NULL);
+            glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, image);
+            eglDestroyImage(qemu_egl_display, image);
+            [cocoaView glDraw];
+            glFinish();
+            [drawable present];
+            return;
+        }
+#endif
+
+        [[cocoaView layer] setNeedsDisplay];
+    });
+}
+
+static void cocoa_gl_update(DisplayChangeListener *dcl,
+                            int x, int y, int w, int h)
+{
+    with_gl_ctx(^{
+        cocoa_gl_scanout_acquire();
+        surface_gl_update_texture(surface, x, y, w, h);
+        cocoa_gl_scanout_release();
+    });
+
+    cocoa_gl_dispatch_display();
+}
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface)
+{
+    with_gl_ctx(^{
+        cocoa_gl_scanout_acquire();
+        surface_gl_destroy_texture(surface);
+        surface_gl_create_texture(new_surface);
+        cocoa_gl_scanout_release();
+    });
+
+    gl_scanout_id = new_surface->texture;
+#ifdef CONFIG_EGL
+    gl_scanout_y_flip = !gl_view_ctx;
+#else
+    gl_scanout_y_flip = false;
+#endif
+    gl_scanout_x = 0;
+    gl_scanout_y = 0;
+    cocoa_switch(dcl, new_surface);
+}
+
+static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
+                                     uint32_t backing_id,
+                                     bool backing_y_0_top,
+                                     uint32_t backing_width,
+                                     uint32_t backing_height,
+                                     uint32_t x, uint32_t y,
+                                     uint32_t w, uint32_t h,
+                                     void *d3d_tex2d)
+{
+    cocoa_gl_scanout_acquire();
+
+    gl_scanout_id = backing_id;
+#ifdef CONFIG_EGL
+    gl_scanout_y_flip = gl_view_ctx ? backing_y_0_top : !backing_y_0_top;
+#else
+    gl_scanout_y_flip = !backing_y_0_top;
+#endif
+    gl_scanout_x = x;
+    gl_scanout_y = backing_y_0_top ? backing_height - h - y : y;
+    gl_scanout_flushed = false;
+
+    cocoa_gl_scanout_release();
+}
+
+static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
+                                   uint32_t x, uint32_t y,
+                                   uint32_t w, uint32_t h)
+{
+    cocoa_gl_scanout_acquire();
+    gl_scanout_flushed = true;
+    cocoa_gl_scanout_release();
+    cocoa_gl_dispatch_display();
+}
+
+static const DisplayChangeListenerOps dcl_gl_ops = {
+    .dpy_name               = "cocoa-gl",
+    .dpy_gfx_update         = cocoa_gl_update,
+    .dpy_gfx_switch         = cocoa_gl_switch,
+    .dpy_gfx_check_format   = console_gl_check_format,
+    .dpy_refresh            = cocoa_refresh,
+    .dpy_mouse_set          = cocoa_mouse_set,
+    .dpy_cursor_define      = cocoa_cursor_define,
+
+    .dpy_gl_scanout_texture = cocoa_gl_scanout_texture,
+    .dpy_gl_update          = cocoa_gl_scanout_flush,
+};
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl)
+{
+    return dcl->ops == &dcl_gl_ops;
+}
+
+#endif
+
+static void cocoa_display_early_init(DisplayOptions *o)
+{
+    assert(o->type == DISPLAY_TYPE_COCOA);
+    if (o->has_gl && o->gl) {
+        display_opengl = 1;
+    }
+}
+
 static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    QemuCocoaAppController *controller;
 
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
 
@@ -2100,10 +2513,89 @@
 
     [QemuApplication sharedApplication];
 
+    dcl.con = qemu_console_lookup_default();
+    kbd = qkbd_state_init(dcl.con);
+    surface = qemu_console_surface(dcl.con);
+
     // Create an Application controller
-    QemuCocoaAppController *controller = [[QemuCocoaAppController alloc] init];
+#ifdef CONFIG_OPENGL
+    controller = [[QemuCocoaAppController alloc] initWithGL:opts->gl];
+#else
+    controller = [QemuCocoaAppController new];
+#endif
     [NSApp setDelegate:controller];
 
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        if (opts->gl == DISPLAY_GL_MODE_ES) {
+#ifdef CONFIG_EGL
+            CAMetalLayer *layer = (CAMetalLayer *)[cocoaView layer];
+            QEMUGLParams params = { .major_ver = 3, .minor_ver = 0 };
+            id<MTLDevice> device = [layer preferredDevice];
+            uint64_t id = [device registryID];
+            GLuint fb;
+            GLuint texture;
+
+            if (qemu_egl_init_dpy_metal(DISPLAY_GL_MODE_ES, id)) {
+                exit(1);
+            }
+
+            gl_ctx = qemu_egl_init_ctx();
+            if (!gl_ctx) {
+                exit(1);
+            }
+
+            gl_view_ctx = qemu_egl_create_context(&dgc, &params);
+            if (!gl_view_ctx) {
+                exit(1);
+            }
+
+            eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+                           gl_view_ctx);
+            glGenFramebuffers(1, &fb);
+            glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fb);
+            glGenTextures(1, &texture);
+            glBindTexture(GL_TEXTURE_2D, texture);
+            glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                                   GL_TEXTURE_2D, texture, 0);
+            [layer setDevice:device];
+#else
+            error_report("OpenGLES without EGL is not supported - exiting");
+            exit(1);
+#endif
+        } else {
+            CGLPixelFormatObj format = cocoa_gl_create_cgl_pixel_format(32);
+            CGLContextObj ctx;
+            CGLCreateContext(format, NULL, &ctx);
+            CGLDestroyPixelFormat(format);
+            gl_ctx = (QEMUGLContext)ctx;
+#ifdef CONFIG_EGL
+            gl_view_ctx = EGL_NO_CONTEXT;
+#endif
+        }
+
+        with_gl_ctx(^{
+            cocoa_gl_scanout_release();
+        });
+
+        dcl.ops = &dcl_gl_ops;
+
+        for (unsigned int index = 0; ; index++) {
+            QemuConsole *con = qemu_console_lookup_by_index(index);
+            if (!con) {
+                break;
+            }
+
+            qemu_console_set_display_gl_ctx(con, &dgc);
+        }
+#else
+        error_report("OpenGL is not enabled - exiting");
+        exit(1);
+#endif
+    } else {
+        dcl.ops = &dcl_ops;
+    }
+
     /* if fullscreen mode is to be used */
     if (opts->has_full_screen && opts->full_screen) {
         [[cocoaView window] toggleFullScreen: nil];
@@ -2127,9 +2619,8 @@
         [cocoaView window].styleMask |= NSWindowStyleMaskResizable;
     }
 
-    if (opts->u.cocoa.has_zoom_interpolation && opts->u.cocoa.zoom_interpolation) {
-        zoom_interpolation = kCGInterpolationLow;
-    }
+    zoom_interpolation = opts->u.cocoa.has_zoom_interpolation &&
+                         opts->u.cocoa.zoom_interpolation;
 
     create_initial_menus();
     /*
@@ -2142,9 +2633,6 @@
     add_console_menu_entries();
     addRemovableDevicesMenuItems();
 
-    dcl.con = qemu_console_lookup_default();
-    kbd = qkbd_state_init(dcl.con);
-
     // register vga output callbacks
     register_displaychangelistener(&dcl);
     qemu_add_mouse_mode_change_notifier(&mouse_mode_change_notifier);
@@ -2166,6 +2654,7 @@
 
 static QemuDisplay qemu_display_cocoa = {
     .type       = DISPLAY_TYPE_COCOA,
+    .early_init = cocoa_display_early_init,
     .init       = cocoa_display_init,
 };
 
@@ -2175,3 +2664,7 @@
 }
 
 type_init(register_cocoa);
+
+#ifdef CONFIG_OPENGL
+module_dep("ui-opengl");
+#endif
diff -uar qemu-clean/ui/console-gl.c qemu-fixed/ui/console-gl.c
--- qemu-clean/ui/console-gl.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/console-gl.c	2026-01-13 15:07:39
@@ -44,10 +44,8 @@
     }
 }
 
-void surface_gl_create_texture(QemuGLShader *gls,
-                               DisplaySurface *surface)
+void surface_gl_create_texture(DisplaySurface *surface)
 {
-    assert(gls);
     assert(QEMU_IS_ALIGNED(surface_stride(surface), surface_bytes_per_pixel(surface)));
 
     if (surface->texture) {
@@ -144,14 +142,11 @@
     return false;
 }
 
-void surface_gl_update_texture(QemuGLShader *gls,
-                               DisplaySurface *surface,
+void surface_gl_update_texture(DisplaySurface *surface,
                                int x, int y, int w, int h)
 {
     uint8_t *data = (void *)surface_data(surface);
 
-    assert(gls);
-
     if (surface->texture) {
         glBindTexture(GL_TEXTURE_2D, surface->texture);
         glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT,
@@ -176,8 +171,7 @@
     qemu_gl_run_texture_blit(gls, false);
 }
 
-void surface_gl_destroy_texture(QemuGLShader *gls,
-                                DisplaySurface *surface)
+void surface_gl_destroy_texture(DisplaySurface *surface)
 {
     if (!surface || !surface->texture) {
         return;
diff -uar qemu-clean/ui/console.c qemu-fixed/ui/console.c
--- qemu-clean/ui/console.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/console.c	2026-01-13 15:07:39
@@ -1487,12 +1487,7 @@
 
 DisplaySurface *qemu_console_surface(QemuConsole *console)
 {
-    switch (console->scanout.kind) {
-    case SCANOUT_SURFACE:
-        return console->surface;
-    default:
-        return NULL;
-    }
+    return console->surface;
 }
 
 PixelFormat qemu_default_pixelformat(int bpp)
diff -uar qemu-clean/ui/dbus.c qemu-fixed/ui/dbus.c
--- qemu-clean/ui/dbus.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/dbus.c	2026-01-13 15:07:39
@@ -63,20 +63,20 @@
 static void
 dbus_create_texture(DisplayGLCtx *ctx, DisplaySurface *surface)
 {
-    surface_gl_create_texture(ctx->gls, surface);
+    surface_gl_create_texture(surface);
 }
 
 static void
 dbus_destroy_texture(DisplayGLCtx *ctx, DisplaySurface *surface)
 {
-    surface_gl_destroy_texture(ctx->gls, surface);
+    surface_gl_destroy_texture(surface);
 }
 
 static void
 dbus_update_texture(DisplayGLCtx *ctx, DisplaySurface *surface,
                     int x, int y, int w, int h)
 {
-    surface_gl_update_texture(ctx->gls, surface, x, y, w, h);
+    surface_gl_update_texture(surface, x, y, w, h);
 }
 
 static const DisplayGLCtxOps dbus_gl_ops = {
@@ -119,9 +119,6 @@
 
 #ifdef CONFIG_OPENGL
     dd->glctx.ops = &dbus_gl_ops;
-    if (display_opengl) {
-        dd->glctx.gls = qemu_gl_init_shader();
-    }
 #endif
     dd->iface = qemu_dbus_display1_vm_skeleton_new();
     dd->consoles = g_ptr_array_new_with_free_func(g_object_unref);
@@ -159,9 +156,6 @@
     g_clear_object(&dd->iface);
     g_free(dd->dbus_addr);
     g_free(dd->audiodev);
-#ifdef CONFIG_OPENGL
-    g_clear_pointer(&dd->glctx.gls, qemu_gl_fini_shader);
-#endif
     dbus_display = NULL;
 }
 
diff -uar qemu-clean/ui/egl-helpers.c qemu-fixed/ui/egl-helpers.c
--- qemu-clean/ui/egl-helpers.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/egl-helpers.c	2026-01-13 15:07:39
@@ -25,6 +25,12 @@
 #include "trace.h"
 #include "standard-headers/drm/drm_fourcc.h"
 
+#define EGL_PLATFORM_ANGLE_ANGLE 0x3202
+#define EGL_PLATFORM_ANGLE_TYPE_ANGLE 0x3203
+#define EGL_PLATFORM_ANGLE_TYPE_METAL_ANGLE 0x3489
+#define EGL_PLATFORM_ANGLE_DEVICE_ID_HIGH_ANGLE 0x34D6
+#define EGL_PLATFORM_ANGLE_DEVICE_ID_LOW_ANGLE 0x34D7
+
 EGLDisplay *qemu_egl_display;
 EGLConfig qemu_egl_config;
 DisplayGLMode qemu_egl_mode;
@@ -89,7 +95,7 @@
     }
 
     egl_fb_delete_texture(fb);
-    glDeleteFramebuffers(1, &fb->framebuffer);
+        glDeleteFramebuffers(1, &fb->framebuffer);
 
     fb->width = 0;
     fb->height = 0;
@@ -466,7 +472,7 @@
 
 /* ---------------------------------------------------------------------- */
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
 {
     EGLSurface esurface;
     EGLBoolean b;
@@ -490,6 +496,80 @@
 
 /* ---------------------------------------------------------------------- */
 
+static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
+{
+    static const EGLint conf_att_core[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    static const EGLint conf_att_gles[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    EGLint major, minor;
+    EGLBoolean b;
+    EGLint n;
+    bool gles = (mode == DISPLAY_GL_MODE_ES);
+
+    qemu_egl_display = dpy;
+
+    b = eglInitialize(qemu_egl_display, &major, &minor);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglInitialize failed");
+        return -1;
+    }
+
+    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglBindAPI failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    b = eglChooseConfig(qemu_egl_display,
+                        gles ? conf_att_gles : conf_att_core,
+                        &qemu_egl_config, 1, &n);
+    if (b == EGL_FALSE || n != 1) {
+        error_report("egl: eglChooseConfig failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    qemu_egl_mode = gles ? DISPLAY_GL_MODE_ES : DISPLAY_GL_MODE_CORE;
+    return 0;
+}
+
+int qemu_egl_init_dpy_metal(DisplayGLMode mode, uint64_t id)
+{
+    EGLAttrib attribs[] = {
+        EGL_PLATFORM_ANGLE_TYPE_ANGLE,
+        EGL_PLATFORM_ANGLE_TYPE_METAL_ANGLE,
+        EGL_PLATFORM_ANGLE_DEVICE_ID_HIGH_ANGLE,
+        id >> 32,
+        EGL_PLATFORM_ANGLE_DEVICE_ID_LOW_ANGLE,
+        id,
+        EGL_NONE
+    };
+    EGLDisplay dpy = eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE, 0,
+                                           attribs);
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetPlatformDisplay failed");
+        return -1;
+    }
+
+    return qemu_egl_init_dpy(dpy, mode);
+}
+
 #if defined(CONFIG_X11) || defined(CONFIG_GBM) || defined(WIN32)
 
 /*
@@ -520,8 +600,9 @@
  * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
  * like mesa will be able to advertise these (even though it can do EGL 1.5).
  */
-static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
-                                       EGLenum platform)
+static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
+                                      EGLenum platform,
+                                      DisplayGLMode mode)
 {
     EGLDisplay dpy = EGL_NO_DISPLAY;
 
@@ -536,66 +617,13 @@
         /* fallback */
         dpy = eglGetDisplay(native);
     }
-    return dpy;
-}
 
-static int qemu_egl_init_dpy(EGLNativeDisplayType dpy,
-                             EGLenum platform,
-                             DisplayGLMode mode)
-{
-    static const EGLint conf_att_core[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    static const EGLint conf_att_gles[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    EGLint major, minor;
-    EGLBoolean b;
-    EGLint n;
-    bool gles = (mode == DISPLAY_GL_MODE_ES);
-
-    qemu_egl_display = qemu_egl_get_display(dpy, platform);
-    if (qemu_egl_display == EGL_NO_DISPLAY) {
-        error_report("egl: eglGetDisplay failed: %s", qemu_egl_get_error_string());
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
         return -1;
     }
 
-    b = eglInitialize(qemu_egl_display, &major, &minor);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglInitialize failed: %s", qemu_egl_get_error_string());
-        return -1;
-    }
-
-    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglBindAPI failed (%s mode): %s",
-                     gles ? "gles" : "core", qemu_egl_get_error_string());
-        return -1;
-    }
-
-    b = eglChooseConfig(qemu_egl_display,
-                        gles ? conf_att_gles : conf_att_core,
-                        &qemu_egl_config, 1, &n);
-    if (b == EGL_FALSE || n != 1) {
-        error_report("egl: eglChooseConfig failed (%s mode): %s",
-                     gles ? "gles" : "core", qemu_egl_get_error_string());
-        return -1;
-    }
-
-    qemu_egl_mode = gles ? DISPLAY_GL_MODE_ES : DISPLAY_GL_MODE_CORE;
-    return 0;
+    return qemu_egl_init_dpy(dpy, mode);
 }
 
 #endif
@@ -604,18 +632,18 @@
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_KHR_platform_x11
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_X11_KHR, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_MESA_platform_gbm
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_GBM_MESA, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 #endif
diff -uar qemu-clean/ui/gtk-egl.c qemu-fixed/ui/gtk-egl.c
--- qemu-clean/ui/gtk-egl.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/gtk-egl.c	2026-01-13 15:07:39
@@ -36,8 +36,8 @@
                        vc->gfx.esurface, vc->gfx.ectx);
         egl_fb_destroy(&vc->gfx.guest_fb);
         if (vc->gfx.surface) {
-            surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-            surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
+            surface_gl_destroy_texture(vc->gfx.ds);
+            surface_gl_create_texture(vc->gfx.ds);
         }
     }
 }
@@ -57,7 +57,7 @@
     }
 
     vc->gfx.ectx = qemu_egl_init_ctx();
-    vc->gfx.esurface = qemu_egl_init_surface_x11
+    vc->gfx.esurface = qemu_egl_init_surface
         (vc->gfx.ectx, (EGLNativeWindowType)x11_window);
 
     assert(vc->gfx.esurface);
@@ -133,13 +133,13 @@
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
-    if (!vc->gfx.gls || !vc->gfx.ds) {
+    if (!vc->gfx.ds) {
         return;
     }
 
     eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
                    vc->gfx.esurface, vc->gfx.ectx);
-    surface_gl_update_texture(vc->gfx.gls, vc->gfx.ds, x, y, w, h);
+    surface_gl_update_texture(vc->gfx.ds, x, y, w, h);
     vc->gfx.glupdates++;
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE,
                    EGL_NO_SURFACE, EGL_NO_CONTEXT);
@@ -165,8 +165,8 @@
         }
         vc->gfx.gls = qemu_gl_init_shader();
         if (vc->gfx.ds) {
-            surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-            surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
+            surface_gl_destroy_texture(vc->gfx.ds);
+            surface_gl_create_texture(vc->gfx.ds);
         }
 #ifdef CONFIG_GBM
         if (vc->gfx.guest_fb.dmabuf) {
@@ -201,10 +201,10 @@
     eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,
                    vc->gfx.esurface, vc->gfx.ectx);
 
-    surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
+    surface_gl_destroy_texture(vc->gfx.ds);
     vc->gfx.ds = surface;
     if (vc->gfx.gls) {
-        surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
+        surface_gl_create_texture(vc->gfx.ds);
     }
 
     if (resized) {
diff -uar qemu-clean/ui/gtk-gl-area.c qemu-fixed/ui/gtk-gl-area.c
--- qemu-clean/ui/gtk-gl-area.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/gtk-gl-area.c	2026-01-13 15:07:39
@@ -29,8 +29,8 @@
         gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
         egl_fb_destroy(&vc->gfx.guest_fb);
         if (vc->gfx.surface) {
-            surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-            surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
+            surface_gl_destroy_texture(vc->gfx.ds);
+            surface_gl_create_texture(vc->gfx.ds);
         }
     }
 }
@@ -147,12 +147,12 @@
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
-    if (!vc->gfx.gls || !vc->gfx.ds) {
+    if (!vc->gfx.ds) {
         return;
     }
 
     gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
-    surface_gl_update_texture(vc->gfx.gls, vc->gfx.ds, x, y, w, h);
+    surface_gl_update_texture(vc->gfx.ds, x, y, w, h);
     vc->gfx.glupdates++;
     gdk_gl_context_clear_current();
 }
@@ -191,7 +191,7 @@
         gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
         vc->gfx.gls = qemu_gl_init_shader();
         if (vc->gfx.ds) {
-            surface_gl_create_texture(vc->gfx.gls, vc->gfx.ds);
+            surface_gl_create_texture(vc->gfx.ds);
         }
     }
 
@@ -220,8 +220,8 @@
 
     if (vc->gfx.gls) {
         gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
-        surface_gl_destroy_texture(vc->gfx.gls, vc->gfx.ds);
-        surface_gl_create_texture(vc->gfx.gls, surface);
+        surface_gl_destroy_texture(vc->gfx.ds);
+        surface_gl_create_texture(surface);
     }
     vc->gfx.ds = surface;
 
diff -uar qemu-clean/ui/gtk.c qemu-fixed/ui/gtk.c
--- qemu-clean/ui/gtk.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/gtk.c	2026-01-13 15:07:39
@@ -342,7 +342,7 @@
     int ww, wh;
     ww = gdk_window_get_width(gtk_widget_get_window(area));
     wh = gdk_window_get_height(gtk_widget_get_window(area));
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls && gtk_use_gl_area) {
         gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
         return;
@@ -563,7 +563,7 @@
 };
 
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static bool gd_has_dmabuf(DisplayChangeListener *dcl)
 {
@@ -674,7 +674,7 @@
 };
 #endif
 
-#endif /* CONFIG_OPENGL */
+#endif /* defined(CONFIG_OPENGL) && defined(CONFIG_EGL) */
 
 /** QEMU Events **/
 
@@ -752,7 +752,7 @@
     dpy_set_ui_info(vc->gfx.dcl.con, &info, true);
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static gboolean gd_render_event(GtkGLArea *area, GdkGLContext *context,
                                 void *opaque)
@@ -906,7 +906,7 @@
     int ww_widget, wh_widget, ww_surface, wh_surface;
     int fbw, fbh;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls) {
         if (gtk_use_gl_area) {
             /* invoke render callback please */
@@ -1465,7 +1465,7 @@
                                     vc->tab_item, vc->label);
     gtk_widget_destroy(vc->window);
     vc->window = NULL;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.esurface) {
         eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
         vc->gfx.esurface = NULL;
@@ -1504,7 +1504,7 @@
     if (!vc->window) {
         gtk_widget_set_sensitive(vc->menu_item, false);
         vc->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         if (vc->gfx.esurface) {
             eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
             vc->gfx.esurface = NULL;
@@ -2116,7 +2116,7 @@
 {
     g_signal_connect(vc->gfx.drawing_area, "draw",
                      G_CALLBACK(gd_draw_event), vc);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (gtk_use_gl_area) {
         /* wire up GtkGlArea events */
         g_signal_connect(vc->gfx.drawing_area, "render",
@@ -2232,7 +2232,7 @@
     return machine_menu;
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static void gl_area_realize(GtkGLArea *area, VirtualConsole *vc)
 {
     gtk_gl_area_make_current(area);
@@ -2271,7 +2271,7 @@
     vc->gfx.scale_x = vc->gfx.preferred_scale;
     vc->gfx.scale_y = vc->gfx.preferred_scale;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (display_opengl) {
         if (gtk_use_gl_area) {
             vc->gfx.drawing_area = gtk_gl_area_new();
@@ -2639,7 +2639,7 @@
 
     assert(opts->type == DISPLAY_TYPE_GTK);
     if (opts->has_gl && opts->gl != DISPLAY_GL_MODE_OFF) {
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #if defined(GDK_WINDOWING_WAYLAND)
         if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
             gtk_use_gl_area = true;
@@ -2682,6 +2682,6 @@
 
 type_init(register_gtk);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff -uar qemu-clean/ui/meson.build qemu-fixed/ui/meson.build
--- qemu-clean/ui/meson.build	2026-01-12 19:51:18
+++ qemu-fixed/ui/meson.build	2026-01-13 15:07:39
@@ -58,15 +58,16 @@
 if opengl.found()
   opengl_ss = ss.source_set()
   opengl_ss.add(gbm, pixman)
-  opengl_ss.add(when: [opengl],
-               if_true: files('shader.c', 'console-gl.c', 'egl-helpers.c', 'egl-context.c'))
+  opengl_ss.add(when: [opengl], if_true: files('shader.c', 'console-gl.c'))
+  opengl_ss.add(when: [egl, opengl],
+                if_true: files('egl-helpers.c', 'egl-context.c'))
   ui_modules += {'opengl' : opengl_ss}
 endif
 
 if opengl.found()
   egl_headless_ss = ss.source_set()
-  egl_headless_ss.add(when: [opengl, pixman],
-                      if_true: [files('egl-headless.c'), gbm])
+  egl_headless_ss.add(when: [egl, opengl, gbm, pixman],
+                      if_true: files('egl-headless.c'))
   ui_modules += {'egl-headless' : egl_headless_ss}
 endif
 
@@ -111,8 +112,8 @@
     gtk_ss.add(files('gtk-clipboard.c'))
   endif
   gtk_ss.add(when: x11, if_true: files('x_keymap.c'))
-  gtk_ss.add(when: opengl, if_true: files('gtk-gl-area.c'))
-  gtk_ss.add(when: [x11, opengl], if_true: files('gtk-egl.c'))
+  gtk_ss.add(when: [egl, opengl], if_true: files('gtk-gl-area.c'))
+  gtk_ss.add(when: [egl, x11, opengl], if_true: files('gtk-egl.c'))
   ui_modules += {'gtk' : gtk_ss}
 endif
 
@@ -123,7 +124,7 @@
     'sdl2-input.c',
     'sdl2.c',
   ))
-  sdl_ss.add(when: opengl, if_true: files('sdl2-gl.c'))
+  sdl_ss.add(when: [egl, opengl], if_true: files('sdl2-gl.c'))
   sdl_ss.add(when: x11, if_true: files('x_keymap.c'))
   ui_modules += {'sdl' : sdl_ss}
 endif
diff -uar qemu-clean/ui/sdl2-gl.c qemu-fixed/ui/sdl2-gl.c
--- qemu-clean/ui/sdl2-gl.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/sdl2-gl.c	2026-01-13 15:07:39
@@ -40,8 +40,8 @@
     if (!scon->scanout_mode) {
         egl_fb_destroy(&scon->guest_fb);
         if (scon->surface) {
-            surface_gl_destroy_texture(scon->gls, scon->surface);
-            surface_gl_create_texture(scon->gls, scon->surface);
+            surface_gl_destroy_texture(scon->surface);
+            surface_gl_create_texture(scon->surface);
         }
     }
 }
@@ -72,7 +72,7 @@
     }
 
     SDL_GL_MakeCurrent(scon->real_window, scon->winctx);
-    surface_gl_update_texture(scon->gls, scon->surface, x, y, w, h);
+    surface_gl_update_texture(scon->surface, x, y, w, h);
     scon->updates++;
 }
 
@@ -85,7 +85,7 @@
     assert(scon->opengl);
 
     SDL_GL_MakeCurrent(scon->real_window, scon->winctx);
-    surface_gl_destroy_texture(scon->gls, scon->surface);
+    surface_gl_destroy_texture(scon->surface);
 
     scon->surface = new_surface;
 
@@ -105,7 +105,7 @@
         sdl2_window_resize(scon);
     }
 
-    surface_gl_create_texture(scon->gls, scon->surface);
+    surface_gl_create_texture(scon->surface);
 }
 
 void sdl2_gl_refresh(DisplayChangeListener *dcl)
diff -uar qemu-clean/ui/sdl2.c qemu-fixed/ui/sdl2.c
--- qemu-clean/ui/sdl2.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/sdl2.c	2026-01-13 15:07:39
@@ -93,7 +93,7 @@
     if (scon->hidden) {
         flags |= SDL_WINDOW_HIDDEN;
     }
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (scon->opengl) {
         flags |= SDL_WINDOW_OPENGL;
     }
@@ -155,7 +155,7 @@
 static void sdl2_redraw(struct sdl2_console *scon)
 {
     if (scon->opengl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_gl_redraw(scon);
 #endif
     } else {
@@ -795,7 +795,7 @@
     .dpy_cursor_define    = sdl_mouse_define,
 };
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static const DisplayChangeListenerOps dcl_gl_ops = {
     .dpy_name                = "sdl2-gl",
     .dpy_gfx_update          = sdl2_gl_update,
@@ -829,7 +829,7 @@
 {
     assert(o->type == DISPLAY_TYPE_SDL);
     if (o->has_gl && o->gl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         display_opengl = 1;
 #endif
     }
@@ -896,7 +896,7 @@
         }
         sdl2_console[i].idx = i;
         sdl2_console[i].opts = o;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_console[i].opengl = display_opengl;
         sdl2_console[i].dcl.ops = display_opengl ? &dcl_gl_ops : &dcl_2d_ops;
         sdl2_console[i].dgc.ops = display_opengl ? &gl_ctx_ops : NULL;
@@ -968,6 +968,6 @@
 
 type_init(register_sdl1);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff -uar qemu-clean/ui/spice-display.c qemu-fixed/ui/spice-display.c
--- qemu-clean/ui/spice-display.c	2026-01-12 19:51:18
+++ qemu-fixed/ui/spice-display.c	2026-01-13 15:07:39
@@ -889,7 +889,7 @@
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
 
-    surface_gl_update_texture(ssd->gls, ssd->ds, x, y, w, h);
+    surface_gl_update_texture(ssd->ds, x, y, w, h);
     ssd->gl_updates++;
 }
 
@@ -957,11 +957,11 @@
                                         num_planes,
                                         modifier);
         if (!ret) {
-            surface_gl_destroy_texture(ssd->gls, ssd->ds);
+            surface_gl_destroy_texture(ssd->ds);
             warn_report("spice: no texture available to display");
         }
     } else {
-        surface_gl_destroy_texture(ssd->gls, ssd->ds);
+        surface_gl_destroy_texture(ssd->ds);
         ssd->ds->texture = texture;
         ssd->ds->mem_obj = mem_obj;
     }
@@ -997,7 +997,7 @@
     bool ret;
 
     if (ssd->ds) {
-        surface_gl_destroy_texture(ssd->gls, ssd->ds);
+        surface_gl_destroy_texture(ssd->ds);
     }
     ssd->ds = new_surface;
     if (ssd->ds) {
@@ -1005,7 +1005,7 @@
         int fd[DMABUF_MAX_PLANES], num_planes, fourcc;
         uint64_t modifier;
 
-        surface_gl_create_texture(ssd->gls, ssd->ds);
+        surface_gl_create_texture(ssd->ds);
         if (!egl_dmabuf_export_texture(ssd->ds->texture,
                                        fd,
                                        (EGLint *)offset,
@@ -1013,13 +1013,13 @@
                                        &fourcc,
                                        &num_planes,
                                        &modifier)) {
-            surface_gl_destroy_texture(ssd->gls, ssd->ds);
+            surface_gl_destroy_texture(ssd->ds);
             return;
         }
 
         ret = spice_gl_replace_fd_texture(ssd, fd, &modifier, &num_planes);
         if (!ret) {
-            surface_gl_destroy_texture(ssd->gls, ssd->ds);
+            surface_gl_destroy_texture(ssd->ds);
             return;
         }
 
