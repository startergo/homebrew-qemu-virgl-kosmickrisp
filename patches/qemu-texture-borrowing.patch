From: Texture Borrowing Support for Desktop GL
Subject: Add texture borrowing mechanism for Desktop GL (gl=core) on macOS

This patch adds texture borrowing support to enable proper Desktop GL
rendering with NSOpenGLContext. The texture borrowing callback allows
the UI to directly access texture data from virglrenderer, which is
necessary for proper display initialization with Desktop GL on macOS.

diff --git a/hw/display/virtio-gpu-virgl.c b/hw/display/virtio-gpu-virgl.c
--- a/hw/display/virtio-gpu-virgl.c
+++ b/hw/display/virtio-gpu-virgl.c
@@ -17,10 +17,11 @@
 #include "trace.h"
 #include "hw/virtio/virtio.h"
 #include "hw/virtio/virtio-gpu.h"
 #include "hw/virtio/virtio-gpu-bswap.h"
 #include "hw/virtio/virtio-gpu-pixman.h"
+#include "ui/console.h"

 #include "ui/egl-helpers.h"

 #include <virglrenderer.h>

@@ -38,10 +39,42 @@
     }

     return container_of(res, struct virtio_gpu_virgl_resource, base);
 }

+static DisplayGLTexture virgl_borrow_texture_for_scanout(uint32_t id)
+{
+    DisplayGLTexture texture = {};
+    struct virgl_renderer_resource_info info;
+    int ret;
+
+#if VIRGL_VERSION_MAJOR >= 1
+    struct virgl_renderer_resource_info_ext ext;
+    memset(&ext, 0, sizeof(ext));
+#ifdef HAVE_VIRGL_RENDERER_BORROW_TEXTURE_FOR_SCANOUT
+    ret = virgl_renderer_borrow_texture_for_scanout(id, &ext);
+#else
+    ret = virgl_renderer_resource_get_info_ext(id, &ext);
+#endif
+    info = ext.base;
+    texture.d3d_tex2d = ext.d3d_tex2d;
+#else
+    memset(&info, 0, sizeof(info));
+    ret = virgl_renderer_resource_get_info(id, &info);
+#endif
+    if (ret) {
+        return texture;
+    }
+
+    texture.y_0_top = info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP;
+    texture.width = info.width;
+    texture.height = info.height;
+    texture.id = info.tex_id;
+
+    return texture;
+}
+
 #if VIRGL_RENDERER_CALLBACKS_VERSION >= 4
 static void *
 virgl_get_egl_display(G_GNUC_UNUSED void *cookie)
 {
     return qemu_egl_display;
@@ -418,18 +451,17 @@
     if (ss.resource_id && ss.r.width && ss.r.height) {
         struct virgl_renderer_resource_info info;
-        void *d3d_tex2d = NULL;
+        void *d3d_tex2d = (void *)virgl_borrow_texture_for_scanout;

 #if VIRGL_VERSION_MAJOR >= 1
         struct virgl_renderer_resource_info_ext ext;
         memset(&ext, 0, sizeof(ext));
         ret = virgl_renderer_resource_get_info_ext(ss.resource_id, &ext);
         info = ext.base;
-        d3d_tex2d = ext.d3d_tex2d;
 #else
         memset(&info, 0, sizeof(info));
         ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
 #endif
         if (ret) {
             qemu_log_mask(LOG_GUEST_ERROR,
                           "%s: illegal resource specified %d\n",
diff --git a/include/ui/console.h b/include/ui/console.h
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -128,10 +128,20 @@
 /* consoles */

 struct QemuConsoleClass {
     ObjectClass parent_class;
 };
+
+typedef struct DisplayGLTexture {
+    uint32_t id;
+    bool y_0_top;
+    uint32_t width;
+    uint32_t height;
+    void *d3d_tex2d;
+} DisplayGLTexture;
+
+typedef DisplayGLTexture (*DisplayGLTextureBorrower)(uint32_t id);

 typedef struct ScanoutTexture {
     uint32_t backing_id;
     bool backing_y_0_top;
     uint32_t backing_width;
diff --git a/ui/console.c b/ui/console.c
--- a/ui/console.c
+++ b/ui/console.c
@@ -68,10 +68,11 @@
 };

 static DisplayState *display_state;
 static QTAILQ_HEAD(, QemuConsole) consoles =
     QTAILQ_HEAD_INITIALIZER(consoles);
+static DisplayGLTextureBorrower gl_scanout_borrow;

 static void dpy_refresh(DisplayState *s);
 static DisplayState *get_alloc_displaystate(void);
 static bool displaychangelistener_has_dmabuf(DisplayChangeListener *dcl);
 static bool console_compatible_with(QemuConsole *con,
diff --git a/ui/cocoa.m b/ui/cocoa.m
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -104,11 +104,11 @@
 @interface QemuCGLLayer : CAOpenGLLayer
 @end

 static bool gl_dirty;
 static uint32_t gl_scanout_id;
-static bool gl_scanout_y0_top;
+static DisplayGLTextureBorrower gl_scanout_borrow;
 static QEMUGLContext gl_view_ctx;
 static NSOpenGLContext *gl_view_nsctx;

 #ifdef CONFIG_EGL
 static EGLSurface egl_surface;
@@ -2331,11 +2331,18 @@

     if (gl_scanout_id) {
         glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
         glBindTexture(GL_TEXTURE_2D, gl_scanout_id);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
-        qemu_gl_run_texture_blit(dgc.gls, gl_scanout_y0_top);
+
+        /* Use texture borrowing callback for Desktop GL */
+        bool y_0_top = false;
+        if (gl_scanout_borrow) {
+            DisplayGLTexture texture = gl_scanout_borrow(gl_scanout_id);
+            y_0_top = texture.y_0_top;
+        }
+        qemu_gl_run_texture_blit(dgc.gls, y_0_top);
     } else {
         glBindTexture(GL_TEXTURE_2D, surface->texture);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
         surface_gl_render_texture(dgc.gls, surface);
     }
@@ -2366,10 +2373,11 @@
 }

 static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
 {
     gl_scanout_id = 0;
+    gl_scanout_borrow = NULL;
     gl_dirty = true;
 }

 static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
                                      uint32_t backing_id,
@@ -2379,11 +2387,13 @@
                                      uint32_t x, uint32_t y,
                                      uint32_t w, uint32_t h,
                                      void *d3d_tex2d)
 {
     gl_scanout_id = backing_id;
-    gl_scanout_y0_top = backing_y_0_top;
+    /* Store the texture borrowing callback */
+    extern DisplayGLTextureBorrower gl_scanout_borrow;
+    gl_scanout_borrow = (DisplayGLTextureBorrower)(uintptr_t)d3d_tex2d;
     gl_dirty = true;
 }

 static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
                                    uint32_t x, uint32_t y,
